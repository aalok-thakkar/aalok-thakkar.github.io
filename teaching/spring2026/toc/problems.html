<!DOCTYPE html>
<html>

<head>

    <title>Aalok Thakkar</title>

    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="/webpage_files/style.css" type="text/css" media="screen">

</head>

<body id="wide-page">

    <div id="content" class="single-wide">

        <h1>
            Theory of Computation
        </h1>
    
        <div class="entry">

            <div style="text-align: center;">
                <img src="./orders.png" style="width: 350px;" class="center">
                <figcaption>
                    <font size="-1">
                        Vera Molnar, <em>Ordres</em> (1974)</font>
                </figcaption>
            </div>
            
            <div style="text-align: center;">
                    <h3>Practice Problems:</h3><br>
            </div>

                <p>
                    The following is a list 100 challenging practice problems. These problems are not graded, but regular submission helps you stay engaged with the material and reinforce the core concepts. You are welcome to discuss them with classmates or the teaching staff and use any resources or tools you find helpful. Their purpose is to support your learning, not evaluate it.
                    <br>
                    <br>

                    <table class="cage">
                        <tr>
                            <th style="width: 60px;">Date</th>
                            <th>Problem</th>
                        </tr>
                        <tr>
                            <td>Jan 19</td>
                            <td>Let n ‚àà ‚Ñï. Consider the alphabet {a, b} and define the language
                                L<sub>n</sub> to consist of all words in which the difference between the
                                number of occurrences of a and the number of occurrences of b is
                                divisible by n. Show that for all n, L<sub>n</sub> is regular.</td>
                        </tr>
                        <tr>
                            <td>Jan 20</td>
                            <td>Consider a first-order logic specification of a formal language over the alphabet {a, b, c}, with positions in a word as the domain of discourse and unary predicates A(x), B(x), and C(x)
                            indicating that position x contains the symbols a, b, and c, respectively. Let S(x, y) denote that y is the successor of x. Show that the language expressed by the formula: &forall;x ( A(x) &rarr; &exist;y ( S(x, y) &and; B(y) ) ) is regular. Is every language definable by such a first-order formula regular? Can every regular language over {a, b, c} be expressed using such an FOL formula?
                              </td>
                        </tr>
                        <tr>
                            <td>Jan 21</td>
                            <td>Prove that a DFA accepts an infinite language if and only if its transition 
                                graph contains a directed cycle that is both reachable from the initial state 
                                and co-reachable (i.e., some accepting state is reachable from it).</td>
                        </tr>
                        <tr>
                            <td>Jan 22</td>
                            <td>Construct, for every n ‚àà ‚Ñï, a regular language L<sub>n</sub> such that L<sub>n</sub> has an NFA with at most n states, and every equivalent DFA requires at least 2<sup>n</sup> states. 
                                Give a specific language and prove both the upper and lower bounds.
                                </td>
                        </tr>
                        <tr>
                            <td>Jan 23</td>
                            <td>Show that every NFA with multiple accepting states can be transformed into an equivalent NFA with exactly one accepting state. Show that every NFA with multiple initial states can be transformed into 
                                an equivalent NFA with exactly one initial state.</td>
                        </tr>
                        <tr>
                            <td>Jan 24</td>
                            <td>Given a regular language L as a DFA, construct a DFA for the reverse of the language. Show that there is a family of languages L<sub>n</sub> with DFA of size O(n) such that any DFA for the reversed language reverse(L<sub>n</sub>) has size ‚â•2<sup>n</sup>.
                            </td>
                        </tr>
                        <tr>
                            <td>Jan 25</td>
                            <td>For each n‚â•1, construct regular languages A<sub>n</sub> and B<sub>n</sub> over the alphabet {a,b}such that the DFA for A<sub>n</sub> and B<sub>n</sub> are of size O(n) and any DFA for the concatenation language A<sub>n</sub>B<sub>n</sub> has size ‚â•2<sup>n</sup>.
                                </td>
                        </tr>
                        <tr>
                            <td>Jan 26</td>
                            <td>Prove that the language of a unary NFA is a finite union of arithmetic 
                                progressions (i.e., ultimately periodic).</td>
                        </tr>
                        <tr>
                            <td>Jan 27</td>
                            <td>A synchronizing word is a an input to the DFA that sends any state of the DFA to one and the same state. That is, w ‚àà Œ£* such that there exists a state q*, for all states q, Œ¥(q, w) = q*. Design an algorithm to determine if a given DFA has a synchronizing word. Hint: Use subset construction for a naive algorithm.</td>
                        </tr>
                        <tr>
                            <td>Jan 28</td>
                            <td>Consider L<sub>n</sub> from Jan 19. Show that the intersection of all L<sub>p</sub>, taken over every prime number p, is exactly the set of all words in which the number of occurrences of
                                a is equal to the number of occurrences of b.</td>
                        </tr>
                        <tr>
                            <td>Jan 29</td>
                            <td>Prove the pumping lemma: Let L be a regular language. Then there exists a constant p ( such that every word w in L with length at least p can be written as w = xyz, where |xy| ‚â§ p, |y| ‚â• 1, and for all k ‚â• 0, the word xy<sup>k</sup>z is also in L.</td>
                        </tr>
                        <tr>
                            <td>Jan 30</td>
                            <td>Let p(n) be a polynomial with integer coefficients such that p(n) ‚â• 0 for all n ‚àà ‚Ñï. 
                                Consider the unary language L<sub>p</sub> = { a<sup>p(n)</sup> : n ‚àà ‚Ñï }.
                                Prove that L<sub>p</sub> is regular if and only if the polynomial p is
                                at most linear.</td>
                        </tr>
                        <tr>
                            <td>Jan 31</td>
                            <td>Over the alphabet {a,b,c}, define L = { a b<sup>n</sup> c<sup>n</sup> : n &ge; 0 } &cup; { a<sup>k</sup> w : k &ge; 2 and w &isin; {a,b,c}*}. Show that L is not regular and yet it satisfies the pumping lemma (Jan 29 problem).
                              </p></td>
                        </tr>
                        <tr>
                            <td>Feb 1</td>
                            <td>Over the alphabet {a, b}, consider the set of all words in which the number of occurrences of a is equal to the number of occurrences of b. Show that this language is not regular. Using the answers of problems from Jan 19, Jan 28, and Feb 1, arrive at a contradiction to the claim that there are finitely many prime numbers.</td>
                        </tr>
                        <tr>
                            <td>Feb 2</td>
                            <td>Let Œ£ be a finite alphabet and let L ‚äÜ Œ£* be a language (not necessarily regular). Let M be the set of equivalence classes induced by the Myhill-Nerode relation (for w ‚àà Œ£*, let [w] denote its equivalence class). Define a binary operation on M by: [x] ‚ãÖ [y] = [xy]. Prove that (M, ‚ãÖ, [Œµ]) is a well defined monoid. This monoid is called the syntactic monoid of the language L.</td>
                        </tr>
                        <tr>
                            <td>Feb 3</td>
                            <td>A language L is recognised by a monoid M if there exists a map œÜ:Œ£* ‚Üí M and a subset F‚äÜM such that L=œÜ^(-1)(F). Equivalently, L consists exactly of those words whose image under œÜ lies in F. A finite monoid M is called aperiodic if for every element s ‚àà M there exists a positive integer k such that s^k = s^(k+1).
                            Give an explicit example of a regular language whose syntactic monoid is aperiodic, and one whose syntactic monoid is not aperiodic.
                            </td>
                        </tr>
                        <tr>
                            <td>Feb 4</td>
                            <td> Let A,B ‚äÜ Œ£* be regular, and let M(A) and M(B) be their syntactic monoids. Consider P = M(A) √ó M(B). Define œÜ(w): Œ£* ‚Üí P and a subset F ‚äÜ P such that w ‚àà A ‚à© B if and only if œÜ(w)‚ààF. This is effectively the Cartesian product construction to show that regular languages are closed under intersection.
                            </td>
                        </tr>
                        <tr>
                            <td>Feb 5</td>
                            <td>Let A,B ‚äÜ Œ£* be regular, and let M(A) and M(B) be their syntactic monoids. Consider P = ùí´(M(A) √ó M(B)) (set of all subsets of M(A)√óM(B)). Define œÜ(w): Œ£* ‚Üí P and a subset F ‚äÜ P such that w ‚àà A¬∑B if and only if œÜ(w)‚ààF. This is effectively the powerset construction to show that regular languages are closed under concatenation.</td>
                        </tr>
                        <tr>
                            <td>Feb 6</td>
                            <td>Given regular expressions r, s, give a direct inductive proof that L(r) ‚à© L(s) is regular without invoking automata.</td>
                        </tr>
                        <tr>
                            <td>Feb 7</td>
                            <td>Define ùí´(M) = { S | S ‚äÜ M } with multiplication S ¬∑ T = { s¬∑t | s ‚àà S, t ‚àà T }, and {1} as the identity. Prove that if M is aperiodic then so are ùí´(M) and M√óN (component-wise product).</td>
                        </tr>
                        <tr>
                            <td>Feb 8</td>
                            <td>A regular language is called star-free if it can be built from finite languages using only union, concatenation, and complement, but not the Kleene star. Prove that its syntactic monoid of a star-free language is aperiodic (Hint: Feb 5-7 problems). Is the converse true?</td>
                        </tr>
                        <tr>
                            <td>Feb 9</td>
                            <td>Construct a weighted automaton over the real numbers with a single symbol alphabet {a} that generates a geometric distribution over strings. The automaton should assign weight (1 ‚àí Œ±) Œ±^k to the string a^k (for a parameter Œ±).
Now consider a generalisation, denoted D(Œ±, m, c). This distribution assigns weight (1 ‚àí Œ±) Œ±^k to strings of the form a^(mk + c), and assigns weight 0 to all other strings (that is, strings whose length is not congruent to c modulo m).
Show that this generalised distribution can also be represented by a weighted automaton.
 </td>
                        </tr>
                        <tr>
                            <td>Feb 10</td>
                            <td>Create a weighted automaton over the real numbers with a single symbol alphabet {a} that maps a^n to n. Show that no deterministic weighted automata (that is an automata where every state has at most one outgoing transition labelled a, or where every word has a unique run) over reals can express this function.</td>
                        </tr>
                        <tr>
                            <td>Feb 11</td>
                            <td>Consider languages R, S, and T (not necessarily regular). Show that 
                                (i) {Œµ}+R¬∑R* = R*, (ii) R¬∑R* = R¬∑R*, and (iii) if X=(R¬∑X) ‚à™ S then X=R*¬∑S. If Y = (R¬∑Y) ‚à™  (S¬∑Y) ‚à™ T, what does it imply about Y? </td>
                        </tr>
                        <tr>
                            <td>Feb 12</td>
                            <td>Let L be a language (not necessarily regular) over a singleton alphabet Œ£ = {a}. Show that L* is regular.</td>
                        </tr>
                        <tr>
                            <td>Feb 13</td>
                            <td>If r is a regular expression, Consider a new operation <span style="text-decoration: overline;">r</span> to denote its complement. That is L(<span style="text-decoration: overline;">r</span>) = Œ£* \ L(r). Regular expressions with only concatenation, union, and complement correspond to star-free languages (Feb 8 problem). Provide a star-free regular expression for the following languages: (i) { w in Œ£* | w contains at least one a }, (ii) (ab)* (all repitions of ab), and (iii) {w‚ààŒ£* | between the first and last a (if they exist) there is no b}.</td>
                        </tr>
                        <tr>
                            <td>Feb 14</td>
                            <td>Consider a system of linear equations over finite languages, that is, a system of equations of the form X<sub>i</sub> = Œ£<sub>j</sub> (c<sub>ij</sub> * X<sub>j</sub>) + d<sub>i</sub>, where each c<sub>ij</sub> and each d<sub>i</sub> is a finite language. Show that if this system has a solution then this solution is unique, and every component language of the solution is regular.</td>
                        </tr>
                        <tr>
                            <td>Feb 15</td>
                            <td>Prove that no weighted automata over real numbers with a singleton alphabet {a} can express the function f(a<sup>n</sup>) = Œª<sup>n</sup> * e<sup>-Œª</sup> / n! (the Poisson distribution with parameter Œª).</td>
                        </tr>
                        <tr>
                            <td>Feb 16</td>
                            <td>Similar to a push-down automaton with a stack, consider a <em>finite-state automaton with a queue</em>. Show that any langauge accepted by a push-down automaton with a stack is also accepted by a <em>finite-state automaton with a queue</em>.</td>
                        </tr>
                        <tr>
                            <td>Feb 17</td>
                            <td>Show that any language accepted by a <em>finite-state automaton with an array</em> is regular. Note that the array length is a fixed constant independent of the input length. </td>
                        </tr>
                        <tr>
                            <td>Feb 18</td>
                            <td>Show that L = { ww  |  w ‚àà Œ£* } can be accepted by a non-deterministic <em>finite-state automaton with a queue</em> (Feb 16 problem), but not a push-down automaton with a stack.</td>
                        </tr>
                        <tr>
                            <td>Feb 19</td>
                            <td>A context-free grammar is linear if each production contains at most one non-terminal. Show that the language of well-balanced parentheses cannot be generated by a linear grammar.</td>
                        </tr>
                        <tr>
                            <td>Feb 20</td>
                            <td>This problem extends the problem for Feb 14. Consider a system of polynomial equations over finite languages. Show that if this system has a solution then this solution is unique, and every component language of the solution is context-free language.</td>
                        </tr>
                        <tr>
                            <td>Feb 21</td>
                            <td>Prove that the set of context-free languages is closed under union, concatenation, and Kleene star.</td>
                        </tr>
                        <tr>
                            <td>Feb 22</td>
                            <td>Prove that the intersection of a regular language and a context-free language is context-free. The intersection of two context-free languages is not context-free. Using the result of Feb 21 problem, show that the set of context-free languages is not closed under complementation.</td>
                        </tr>
                        <tr>
                            <td>Feb 23</td>
                            <td>A deterministic Turing machine has a single infinite tape and a read/write head. Prove that a finite-state automaton with two stacks can simulate a deterministic Turing machine.</td>
                        </tr>
                        <tr>
                            <td>Feb 24</td>
                            <td>A k-counter machine is like a finite automaton equipped with k integer counters. Each counter can be incremented, decremented, and tested for zero. Show that a push-down automaton (with a stack) can simulate a 1-counter machine, but not vice-versa.</td>
                        </tr>
                        <tr>
                            <td>Feb 25</td>
                            <td>Show that a deterministic k-tape Turing machine (TM) that runs in time T(n) on inputs of length n can be simulated by a single-tape Turing machine in time O(T(n)<sup>2</sup>).</td>
                        </tr>
                        <tr>
                            <td>Feb 26</td>
                            <td>A Random Access Machine consists of a finite state machine (control unit), a finite number of registers for temporary storage, and an unbounded sequence of memory cells that can store integers. Unlike a Turing machine, which accesses memory sequentially along a tape, a RAM can directly access any memory cell in a single step, hence the term "random access." The machine operates by executing a sequence of instructions, which include arithmetic operations (such as addition, subtraction, and multiplication), data transfer between registers and memory cells, and conditional branching based on the contents of registers. Show that RAM is computationally equivalent to a deterministic Turing machine.</td>
                        </tr>
                        <tr>
                            <td>Feb 27</td>
                            <td>Consider the language {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>‚à£n‚â•1}. Show that this language can be simulated by a 2-counter machine but not a 1-counter machine (and hence not a push-down automaton). </td>
                        </tr>
                        <tr>
                            <td>Feb 28</td>
                            <td>An unrestricted grammar is a grammar in which each production rule has the form Œ± ‚Üí Œ≤, where Œ± is a non-empty string of terminals and/or non-terminals, and Œ≤ is any string of terminals and/or non-terminals (possibly empty). Show that every the class of languages generated by unrestricted grammars is equivalent to the class of languages accepted by a nondeterministic Turing machine.</td>
                        </tr>
                        <tr>
                            <td>Mar 1</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 3</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 4</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 6</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 8</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 9</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 11</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 12</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 13</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 14</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 15</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 16</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 17</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 18</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 19</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 20</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 21</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 22</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 23</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 24</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 25</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 26</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 27</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 28</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 29</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 30</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Mar 31</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 1</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 3</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 4</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 6</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 7</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 8</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 9</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 10</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 11</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 12</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 13</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 14</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 15</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 16</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 17</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 18</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 19</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 20</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 21</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 22</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 23</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 24</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 25</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 26</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 27</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Apr 28</td>
                            <td></td>
                        </tr>
                        
                        
                        
                    </table>
                </p>

            </div>
            <p style="text-align: center;">
                back to <a href="./index.html">course</a>
            </p>

           
                            </div>

    </div>

    <div id="footer"></div>

    <script>
    fetch("/webpage_files/footer.html")
      .then(response => response.text())
      .then(data => {
        document.getElementById('footer').innerHTML = data;
      });
    </script>
    

</body>

</html>